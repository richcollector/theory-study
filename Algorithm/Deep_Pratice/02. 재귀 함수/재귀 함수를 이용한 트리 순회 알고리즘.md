## 재귀 함수를 이용한 트리 순회 알고리즘

트리 순회는 트리 자료구조에서 각 노드를 한 번씩 탐색하는 알고리즘을 말합니다. 이 트리 순회는 여러 방법이 있지만 재귀를 이용할 수 있는 순회는 전위 순회(Preorder), 중위 순회(Inorder), 후위 순회(Postorder)가 있습니다. 모든 순회는 루트 노드부터 시작하며 어떤 노드를 먼저 방문하는지가 달라집니다. 여기서는 이진 트리를 이용하여 설명드리겠습니다.

### 전위 순회

전위 순회는 (1)먼저 노드를 방문한 후 (2)왼쪽 서브 트리를 전위 순회한 다음에 (3)오른쪽 서브 트리를 전위 순회하는 방식을 의미합니다. 다음과 같은 이진 트리가 있다고 가정 해보겠습니다.

```
       1
      / \
     /   \
    2     \
   / \     3
  4   5   / \
         6   \
              7
             / \
            8   9
```

- 위 트리에서 전위 순회는 다음과 같이 동작합니다.
  - 우선 1을 방문합니다.
  - 1의 왼쪽 서브 트리로 이동합니다.
  - 2를 방문합니다.
  - 2의 왼쪽 서브 트리로 이동합니다.
  - 4를 방문합니다.
  - 왼쪽, 오른쪽 서브 트리가 없기에 다시 올라갑니다.
  - 2의 오른쪽 서브 트리로 이동합니다.
  - 5를 방문합니다.
  - 왼쪽, 오른쪽 서브 트리가 없기에 다시 올라갑니다.
  - 왼쪽, 오른쪽 서브 트리를 모두 방문했기에 다시 올라갑니다.
  - 1의 오른쪽 서브 트리로 이동합니다.
  - 3을 방문합니다.
  - 3의 왼쪽 서브 트리로 이동합니다.
  - 6을 방문합니다.
  - 왼쪽, 오른쪽 서브 트리가 없기에 다시 올라갑니다.
  - 3의 오른쪽 서브 트리로 이동합니다.
  - 7을 방문합니다.
  - 7의 왼쪽 서브 트리로 이동합니다.
  - 8을 방문합니다.
  - 왼쪽, 오른쪽 서브 트리가 없기에 다시 올라갑니다.
  - 7의 오른쪽 서브 트리로 이동합니다.
  - 9를 방문합니다.
  - 모든 트리를 순회했기에 종료됩니다.
  - 최종적으로 1, 2, 4, 5, 3, 6, 7, 8, 9 노드 순으로 방문을 하게됩니다. 이를 의사 코드로 나타내자면

```jsx
preorder(tree) {
    방문(tree.root);
    preorder(tree.left);
    preorder(tree.right);
}
```

으로 표현 할 수 있습니다.

### 중위 순회

전위 순회는 (1)왼쪽 서브 트리를 중위 순회한 후 (2)노드를 방문한 다음에 (3)오른쪽 서브 트리를 중위 순회하는 방식을 의미합니다. 다음과 같은 이진 트리가 있다고 가정 해보겠습니다.

```
     1
    / \
   /   \
  2     \
 / \     3
4   5   / \
       6   \
            7
           / \
          8   9
```

- 위 트리에서 중위 순회는 다음과 같이 동작합니다.
  - 1의 왼쪽 서브 트리로 이동합니다.
  - 2의 왼쪽 서브 트리로 이동합니다.
  - 더 이상 왼쪽 서브 트리가 없어 4를 방문합니다.
  - 4의 오른쪽 서브 트리가 없기에 올라갑니다.
  - 2를 방문합니다.
  - 2의 오른쪽 서브 트리로 이동합니다.
  - 더 이상 왼쪽 서브 트리가 없어 5를 방문합니다.
  - 5의 오른쪽 서브 트리가 없기에 올라갑니다.
  - 2에서 왼쪽, 오른쪽 서브 트리를 모두 방문했기에 다시 올라갑니다.
  - 1을 방문합니다.
  - 1의 오른쪽 서브 트리로 이동합니다.
  - 3의 왼쪽 서브 트리로 이동합니다.
  - 더 이상 왼쪽 서브 트리가 없어 6을 방문합니다.
  - 6의 오른쪽 서브 트리가 없기에 올라갑니다.
  - 3을 방문합니다.
  - 3의 오른쪽 서브 트리로 이동합니다.
  - 7의 왼쪽 서브 트리로 이동합니다.
  - 더 이상 왼쪽 서브 트리가 없어 8을 방문합니다.
  - 8의 오른쪽 서브 트리가 없기에 올라갑니다.
  - 7을 방문합니다.
  - 7의 오른쪽 서브 트리로 이동합니다.
  - 더 이상 왼쪽 서브 트리가 없어 9를 방문합니다.
  - 모든 트리를 순회했기에 종료됩니다.
  - 최종적으로 4, 2, 5, 1, 6, 3, 8, 7, 9 노드 순으로 방문을 하게됩니다. 이를 의사 코드로 나타내자면

```jsx
inorder(tree) {
    inorder(tree.left);
    방문(tree.root);
    inorder(tree.right);
}
```

으로 표현 할 수 있습니다.

### 후위 순회

전위 순회는 (1)왼쪽 서브 트리를 후위 순회한 후 (2)오른쪽 서브 트리를 후위 순회한 다음에 (3)노드를 방문하는 방식을 의미합니다. 다음과 같은 이진 트리가 있다고 가정 해보겠습니다.

```
     1
    / \
   /   \
  2     \
 / \     3
4   5   / \
       6   \
            7
           / \
          8   9
```

- 위 트리에서 후위 순회는 다음과 같이 동작합니다.
  - 1의 왼쪽 서브 트리로 이동합니다.
  - 2의 왼쪽 서브 트리로 이동합니다.
  - 더 이상 왼쪽, 오른쪽 서브 트리가 없어 4를 방문합니다.
  - 올라갑니다.
  - 2의 오른쪽 서브 트리로 이동합니다.
  - 더 이상 왼쪽, 오른쪽 서브 트리가 없어 5를 방문합니다.
  - 모든 서브 트리를 방문하였기에 2를 방문합니다.
  - 올라갑니다.
  - 1의 오른쪽 서브 트리로 이동합니다.
  - 3의 왼쪽 서브 트리로 이동합니다.
  - 더 이상 왼쪽, 오른쪽 서브 트리가 없어 6을 방문합니다.
  - 올라갑니다.
  - 3의 오른쪽 서브 트리로 이동합니다.
  - 7의 왼쪽 서브 트리로 이동합니다.
  - 더 이상 왼쪽, 오른쪽 서브 트리가 없어 8을 방문합니다.
  - 올라갑니다.
  - 7의 오른쪽 서브 트리로 이동합니다.
  - 더 이상 왼쪽, 오른쪽 서브 트리가 없어 9를 방문합니다.
  - 올라갑니다.
  - 더 이상 왼쪽, 오른쪽 서브 트리가 없어 7을 방문합니다.
  - 올라갑니다.
  - 더 이상 왼쪽, 오른쪽 서브 트리가 없어 3을 방문합니다.
  - 올라갑니다.
  - 더 이상 왼쪽, 오른쪽 서브 트리가 없어 1을 방문합니다.
  - 최종적으로 4, 5, 2, 6, 8, 9, 7, 3, 1 노드 순으로 방문을 하게됩니다. 이를 의사 코드로 나타내자면

```jsx
postorder(tree) {
    postorder(tree.left);
    postorder(tree.right);
    방문(tree.root);
}
```

으로 표현 할 수 있습니다.

### 구현 코드

이런 전위, 중위, 후위 순회에 대한 재귀 코드 구현은 다음과 같습니다.

```jsx
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class Tree {
  constructor(node) {
    this.root = node;
  }

  preorder(currentNode) {
    // 전위 순회
    console.log(currentNode.value);
    if (currentNode.left) this.preorder(currentNode.left);
    if (currentNode.right) this.preorder(currentNode.right);
  }

  inorder(currentNode) {
    // 중위 순회
    if (currentNode.left) this.inorder(currentNode.left);
    console.log(currentNode.value);
    if (currentNode.right) this.inorder(currentNode.right);
  }

  postorder(currentNode) {
    // 후위 순회
    if (currentNode.left) this.postorder(currentNode.left);
    if (currentNode.right) this.postorder(currentNode.right);
    console.log(currentNode.value);
  }
}

const tree = new Tree(new Node(9));
tree.root.left = new Node(3);
tree.root.right = new Node(8);
tree.root.left.left = new Node(2);
tree.root.left.right = new Node(5);
tree.root.right.right = new Node(7);
tree.root.left.right.right = new Node(4);

tree.preorder(tree.root);
tree.inorder(tree.root);
tree.postorder(tree.root);
```
