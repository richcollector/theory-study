## JWT가 생겨난 과정

로그인 할 때, 인증(Authentication / 세션아이디 받는 과정)과 인가(Authorization / 로그인 했으니 정보를 주는과정)의 과정이 이루어 지는데,로그인을 많은 사용자가 요청을 하게 되면 부하가 발생하게됩니다.
부하를 해결하는 방법으로는 아래와 같은 방법이 있습니다.

- scale-up

  램의 성능을 올리거나, 물리적인 방법을 키우는 방법입니다.

- scale-out

  옆으로 펼칩니다. 즉, 컴퓨터 여러대로 돌리는 것을 말합니다.

scale-out은 로그인 서비스가 없을 때는 사용해도 괜찮지만, scale-out으로 처리한 뒤, 로그인 서비스를 만들면 문제가 발생합니다. 한 컴퓨터가 메모리 세션을 가지고 있는 경우 다른 컴퓨터에서는 로그인 했었는지 확인을 할 수가 없기 때문입니다. 그래서 stateFul(메모리세션을 가지고 있는 상태)인 상태에서는 scale-out이 어렵습니다.

### 세션테이블으 사용

세션테이블을 db에 저장하기 시작하고 stateless(메모리세션이 없는 상태) 상태로 만들어서 scale-out가 쉬워지게 합니다.

세션테이블에 db를 저장하기 시작하면서 다른 문제가 발생하는데, db session테이블 병목현상(bottle-neck / 좁은길에 많은 것들이 모여서 밀리는 현상)이 발생하는 것 입니다.

### Redis

db는 컴퓨터를 늘린다해도 데이터가 많아서 쉽지가 않지만, 다루기가 어려워서 scale-out 방법도 씁니다.
이때, 백앤드 서버를 scale-up하여 같이 사용하기도 합니다.

다른 방법으로는, db테이블 자르는 방법이 있는데, 수직파티셔닝(수직으로 데이터 나누기)과 수평파티셔닝 (가로로 데이터 나누기)이 대표적입니다. 이때, 파티셔닝한 값을 나눠서 담는 법은 데이터베이스 "샤딩"한다고 합니다. db는 이용할 경우 disk input/output이 발생하여 느린속도로 처리가 되는데, 이것을 빠르게 하기위한 캐싱방법으로 redis가 있습니다.

백엔드에서 세션테이블 정보를 객체로 저장하는 방법으로 생각해낸 방식이 JWT입니다. 백엔드에서 로그인 정보를 암호화하고 복호화해서 정보를 확인하는 방식으로, 암호화된 값을 세션id로 사용합니다. accessToken은 로그인용으로 활용하는 JWT고 꼭 로그인에만 사용하는 것은 아닙니다. 간단한 서비스에서 사용하지만, 추가 정보들의 저장이 있을 경우 결국은 redis가 필요합니다.

## JWT 토큰의 구조

JWT토큰은 jwt.io란 페이지가 있는데, 이곳에서 토큰의 증표를 복호화하는 걸 볼 수 있고, 헤더에 accessToken을 넣어 사용하는 구조입니다.

- 인가

  문자열의 형태 => `{"Authorization": "Bearer"}`
  header(암호화방식) / payload(정보) / signature(비밀번호)으로 구성
  위 3개가 합쳐진 것이 JWT입니다.

- payload(정보)의 내용

  - iss

    토큰 발급자 (issuer)

  - sub

    토큰 제목 (subject)

  - aud

    토큰 대상자 (audience)

  - exp

    토큰의 만료시간 (expiraton), 시간은 NumericDate 형식으로 되어있어야 하며 (예: 1480849147370) 언제나 현재 시간보다 이후로 설정되어 있어야 합니다.

  - nbf

    Not Before 를 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 NumericDate 형식으로 날짜를 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않습니다.

  - iat

    토큰이 발급된 시간 (issued at), 이 값을 사용하여 토큰의 age 가 얼마나 되었는지 판단 할 수 있습니다.

  - jti

    JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위하여 사용됩니다. 일회용 토큰에 사용하면 유용합니다.

### accessToken과 refreshToken

accessToken과 refreshToken을 저장하는 곳으로는 여러가지가 있는데 대표적으로는 아래와 같습니다.

- 변수(state)

- LocalStorage

  브라우저를 껏다 켜도 살아있음

- SessionStorage

  브라우저를 껏다 키면 사라짐

- Cookies

  서버랑 긴밀하게 소통

#### 결과

- 변수

  accessToken

- 쿠키

  refreshToken

LocalStorage와 SessionStorage는 보안 이슈로 Cookies에 refreshToken을 사용하게 됩니다.

## Cookies

- `httponly` ⇒ TRUE

  ex) document.cookie로 접근하지 못하게 합니다. (자바스크립트 접근 불가)

- `secure`

  ex) https일때만 사용가능합니다. HTTP에선 사용불가 합니다.
  request에 헤더에 쿠키들이있는데, api를 요청하면 자동으로 딸려들어갑니다.
  토큰이 만료되었는지 체크해줘야하고, 로그인 만료시간 연장 방법 이해하고 만료되었으면 다시 신청해주어야합니다. api요청할 때 쿠키는 자동으로 넘어가 refreshToken이 넘어갑니다.

- 토큰만료에러
- 토큰 재발급
- api를 요청하면, 쿠키에 있는 refreshToken가 자동으로 넘어갑니다.
- 실패쿼리 재시도

이 모든 과정을 유저가 모르게해야 하는데, 실제로 1초도 걸리지 않는다. 이 과정을 slientAuth ⇒ slient Authentication라고도 부릅니다.

요즘 트렌드로는 MSA(마이크로서비스아키텍쳐)가 있는데, 서버를 여러개로 나누어 서비스를 관리하는 것을 말한다. 구조는 아래와 같습니다.

- AuthService
- ResourceService
  - ProfileService
  - BoardService

**다양한 SNS(google, naver, kakao ...)에서 AuthService를 제공해주는 것을 OAuth(Open-Authentication)부른다.**

### JWT의 특징

데이터가 많아지면 길이가 길어지게 됩니다. 누구나 볼 수 있기때문에 중요한 정보는 넣지않고, 최소한의 정보만 담아야합니다. 조작을 할 수 없지만, 조작을 하려면 비밀번호를 넣어야 가능한 부분입니다.

**백엔드에서는 이것이 조작이 되었는지 검사와, 만료시간을 검사를 합니다.**

JWT는 단방향 암호화를 이용하는데, 양방향 암호화의 문제점 때문에 사용하게 됩니다.
