## 자바스크립트의 소수점 계산

고정소수점, 부동소수점 모두 프로그래밍 계산시 0.1 또는 1.2 등 대부분 실수는 나타낼 수 없고, 계산하면 오차값이 생깁니다.

```js
console.log(1.2);

// 1.2
// 그냥 실수를 주입했을 경우에는 toString으로 바로 변환하니 그대로 나온다.

console.log(0.1 + 1.1);

// 1.2000000000000002
// 계산을 하게되면 문제가 발생한다.
```

Value actually stored in float
즉 근사값으로 저장이 됩니다.

가수부(가수, 숫자의 유효한 부분)에 저장 가능한 비트까지만 저장이 되기 때문에 1.1과 가장 가까운 숫자가 저장될 뿐 정확한 수치가 아닙니다.

우리가 보통 계산 할때 사용하는 10진법과 달리 컴퓨터는 2진법으로 동작하는데, 몇몇 소수는 10진법에서 2진법으로 변환하는 과정에서 무한 소수가 되어버립니다. 저장공간에 한계가 있는 컴퓨터는 무한 소수를 유한 소수로 바꾸게 되는데, 이 과정에서 미세한 오차가 발생해서 오류가 발생한 것입니다. (정밀도 문제)

### 해결법

2진법의 근본적인 문제이기 때문에 속시원한 해결방법은 없다고 봐도 됩니다.

- 반올림 처리

  반올림 처리이니 주의합니다.

```jsx
// toFixed 인수로 소수부 자리수를 입력한다.
const result = (0.1 + 1.1).toFixed(5);

// 문자열로 리턴된다.
// '1.20000'

// 숫자로 형변환 한다.
console.log(Number(result));

// 1.2
```

- 라이브러리 사용 (decimal)

  정확한 계산을 해 줍니다. (물론 무한 순환되는 실수는 어쩔 수 없습니다.)

문자열로 나오니 Number등으로 형변환 해줍니다.

[decimal.js](https://github.com/MikeMcl/decimal.js)

```js
0.3 - 0.1; // 0.19999999999999998
x = new Decimal(0.3);
x.minus(0.1); // '0.2'
x; // '0.3'
x.dividedBy(y).plus(z).times(9).floor();
```

### 참고자료

- [자바스크립트 - 실수(float) 정확히 계산하기](https://velog.io/@jaybon/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%EC%88%98float-%EC%A0%95%ED%99%95%ED%9E%88-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0)
